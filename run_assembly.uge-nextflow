#!/usr/bin/env bash
#$ -cwd

# This wrapper script manages job submission of
#  the wf-paired-end-illumina-assembly workflow
#  to the UGE scheduler.
SCRIPT_NAME="$(basename ${0#_} .uge-nextflow)"

# Define script usage
usage() {
  echo "
Usage: ${0##*/} InputDirectory [OutputDirectory] [-h|--help]
  
Required:
  <InputDirectory>   Path containing PE Illumina 1.8+ files as *.fastq.gz
  
  Sample names are extracted from the first underscore of read files. Hyphens,
  periods, and commas are automatically discarded from the name to avoid errors.
  WARNING: If you have HiSeq data where samples are ran on more than one lane,
  be sure to concatenate them.

  File searching goes 2 levels deep to find .fq and .fastq file pairs,
  optionally gunzip compressed.

  Sample pairing of sister reads is done by consecutively using filenames sorted
  with \`ls\`, which flexibly allows for naming other than traditional R1 and R2.
  Verify that files properly will pair by checking the output order of \`ls\`
  within the <InputDirectory>.

Optional:
  -h | --help        Show this help message and exit.
  <OutputDirectory>  Location for the output files, which
                     includes job logfiles. Output files
                     will be overwritten if already present.
                     Default: current working directory.
  "
}

# Allow user to re-specify the output path
prompt_new_outpath() {
  read -p "Would you like to use a different output path? (yes|no)" -n 1 -r
  if [[ $REPLY =~ ^[yY] ]]; then
    read -p "Enter new Output path:" _new_outpath
    OUT="$(readlink -f ${_new_outpath})"
  else
    echo -e "You can re-run this workflow with a new output path."
    echo -e "${RED}Submission was cancelled.${RESET}"
    exit 0
  fi
}

# Check if there is a possibility data will be overwritten
prompt_if_previous_nextflow_run() {
  # Parameters:
  #  $1 = file path
  #  $2 = filename (no path) to search for
  if [ -f "$(find "${1}" -name "${2}" | grep -q '.')" ]; then
    echo -e "\nThis workflow has been ran in output path before."
    echo -e "Processing the same sample names will overwrite older data."
    echo -e "If you have jobs in queue this could be confusing.\n"
    read -p "Do you want to continue? (yes|no)" -n 1 -r
    if [[ $REPLY =~ ^[yY] ]]; then
      # Continue submission if user wants to possibly overwrite data
      echo -e "${GREEN}Data in ${1} will be overwritten."
      echo -e "Continuing to submit samples...\n${RESET}"
    else
      # If user doesn't want to continue, ask for a different output path
      prompt_new_outpath
      prompt_if_previous_nextflow_run "${OUT}" "nextflow_log.${SCRIPT_NAME}.txt"
    fi
  fi
}

# Check argument requirements
[[ $1 == "--help" || $1 == "-h" ]] && { usage; exit 0; }
if [[ $# -lt 1  || $# -gt 2 ]]; then
  echo "ERROR: improper number ("$#") of arguments provided" >&2
  usage
  exit 1
fi

# Confirm we are on a host that can submit jobs
if [ ${HOSTNAME%%.*} == 'biolinux' ] || \
 [ ${HOSTNAME%%.*} == 'login02' ]; then
  :
else
  echo 'ERROR: must be on aspen or biolinux' >&2
  exit 1
fi

# I/O handling
if [[ $1 =~ .+[[:space:]].+ ]]; then
  echo "ERROR: whitespace in $1 path unsupported" >&2
  exit 1
fi
if [[ $2 =~ .+[[:space:]].+ ]]; then
  echo "ERROR: whitespace in $2 path unsupported" >&2
  exit 1
fi
IN=$(readlink -f "$1")
if [[ -z "$2" ]]; then
  OUT="${PWD}"
else
  OUT=$(readlink -f "$2")
fi

# Color output for success, warnings, and errors to catch user's attention
GREEN='\033[0;32m'
RED='\033[0;31m'
RESET='\033[0m'

# Get LAB_HOME or custom tmp/cache variables from user's ~/.bashrc,
#  while still enabling fancy people to override these from their
#  current working environment too.
source ${HOME}/.bashrc
if [[ -z "$LAB_HOME" ]]; then
  echo 'ERROR: $LAB_HOME not set' >&2
  exit 1
fi

# Check if Singularity environment variables are set,
#  and confirm the user has write access.
#  We expect these 2 paths to already exist.
if [[ -z ${SINGULARITY_CACHEDIR} ]]; then
  echo 'ERROR: $SINGULARITY_CACHEDIR not set' >&2
  exit 1
else
  if [[ ! -d ${SINGULARITY_CACHEDIR} ]] || [[ ! -w ${SINGULARITY_CACHEDIR} ]]; then
    echo "ERROR: \$SINGULARITY_CACHEDIR $SINGULARITY_CACHEDIR not writeable for $USER" >&2
    exit 1
  fi
fi
if [[ -z ${SINGULARITY_TMPDIR} ]]; then
  echo 'ERROR: $SINGULARITY_TMPDIR not set' >&2
  exit 1
else
  if [[ ! -d ${SINGULARITY_TMPDIR} ]] || [[ ! -w ${SINGULARITY_TMPDIR} ]]; then
    echo "ERROR: \$SINGULARITY_TMPDIR $SINGULARITY_TMPDIR not writeable for $USER" >&2
    exit 1
  fi
fi

# If Windows-style mount point (e.g., "Z:\Streptobacillus\Raw_FQs") given as a
#  path, check both user's home, lab home, and group as possible mount areas
#  to determine if files exist in 1 but not the others.
if [[ ${IN} =~ ^[A-Z]\:\\.+ ]]; then
  path_slashes_replaced="$(echo "${IN:3}" | sed 's/\\/\//g')"
  user_home="${HOME}"/"${path_slashes_replaced}"
  user_group_main="/scicomp/${path_slashes_replaced}"
  user_group_branch="/scicomp/groups/OID/NCEZID/DHCPP/BSPB/${path_slashes_replaced}"
  lab_home="${LAB_HOME}"/"${path_slashes_replaced}"
  paths=(
    "${user_home}"
    "${user_group_main}"
    "${user_group_branch}"
    "${lab_home}"
    )
  for path in "${paths[@]}"; do
    cnt_read_files=$(find "${path}" \
     -maxdepth 2 \
     -type f \
     -readable \
     -regextype posix-extended \
     -regex ".+\.(fq|fastq)($|\.gz$)" \
     2> /dev/null \
     | wc -l)
    if [[ ${cnt_read_files} -ge 1 ]]; then
        echo "${cnt_read_files} FastQ files found in: ${path}"
        read -p "Use ${path} as Input Directory? (yes|no)" -n 1 -r
        if [[ $REPLY =~ ^[yY] ]]; then
          IN="${path}"
        else
          exit 0
        fi
        break
    fi
  done
fi

# For now, just output into shared LAB_HOME area
if [[ ${OUT} =~ ^[A-Z]\:\\.+ ]]; then
  echo "Windows hard mount path detected as Output Directory"
  proposed_outpath="${LAB_HOME}"/"$(date '+%Y-%b-%d_%a_%H:%M:%S')"
  read -p "Use ${path} as Input Directory? (yes|no)" -n 1 -r
  if [[ $REPLY =~ ^[yY] ]]; then
    OUT="${path}"
  else
    echo "Okay, bad autoselection? Re-run with a different specified path"
    exit 0
  fi
fi

# If Windows-style path from Core Facility given via email
#  (e.g., "\\...cdc.gov\groups\OID\...BCFB\by-instrument\NovaSeq\")
#  is given as path, form the Linux path
if [[ ${IN} =~ ^\\\\.+\.cdc\.gov\\.+\\.+ ]]; then
  inpath_stripped_hostname="${IN/*.cdc\.gov/\/scicomp}"
  inpath_dewindowsed="$(echo "${inpath_stripped_hostname}" | sed 's/\\/\//g')"
  IN="${inpath_dewindowsed}"
fi

# Check for specific nextflow logfile for this workflow, which
#  means this nextflow workflow has been ran before in the specified outpath.
if [ -d "${OUT}/log" ] && \
  [ -f "${OUT}/nextflow_log.${SCRIPT_NAME}.txt" ]; then
  prompt_if_previous_nextflow_run "${OUT}" "nextflow_log.${SCRIPT_NAME}.txt"
fi
# Also check for unsupported behavior combining legacy bash and newer nextflow
if [ -d "${OUT}/.log" ] && \
  [ -f "${OUT}/trim.asm.annot.job_ids.txt" ] && \
  [ -f "${OUT}/trim.asm.annot.log.txt" ]; then
  echo "Legacy bash workflow detected in ${OUT}"
  echo "Combining data from that and this nextflow pipeline is unsupported."
  echo "Use a different output path."
  exit 1
fi

# Add found files to an array
found_files=( $(find ${IN} \
     -maxdepth 2 \
     -type f \
     -readable \
     -regextype posix-extended \
     -regex ".+\.(fq|fastq)($|\.gz$)")
)

# Require even input file count for paired-end analysis
if [ ${#found_files[@]} -lt 1 ]; then
  echo 'ERROR: no read sets found' >&2
  exit 1
fi
if [[ $((${#found_files[@]} % 2)) -ne 0 ]]; then
  echo "ERROR: uneven number (${#found_files[@]}) of FastQ files" >&2
  exit 1
fi

# Pair up the FastQ files based on basename (prefix) to submit jobs
submitted=()
for (( i=0; i<${#found_files[@]}; i+=2 )); do
  read1=${found_files[i]}
  read2=${found_files[i+1]}
  b1=$(basename $read1 | cut -d _ -f 1 | sed 's/[-\.,]//g')
  b2=$(basename $read2 | cut -d _ -f 1 | sed 's/[-\.,]//g')
  if [[ "${submitted[*]}" =~ " ${b1} " ]]; then
    echo "ERROR: $b1 sample name occurs in >1 paired set" >&2
    exit 1
  fi
  if [ "$b1" != "$b2" ]; then
    echo "ERROR: improperly paired $b1 $b2" >&2
    exit 1
  fi
  submitted+=(${b1})
done

# Prompt user if >10 samples to prevent accidentally assembling too many
if [[ ${#submitted[@]} -ge 10 ]]; then
  echo -e "${RED}WARNING:${RESET} ${#submitted[@]} samples have been identified:\n${RESET}"
  echo -e "${submitted[@]}\n"
  
  # Prompt user to verify submission of large sample set
  read -p "Do you want to continue submitting ${#submitted[@]} samples? (yes|no)" -n 1 -r
  if [[ $REPLY =~ ^[yY] ]]; then
    echo -e "Continuing to submit ${#submitted[@]} samples...\n"
  else
    echo -e "Submission cancelled"
    exit 0
  fi
fi

# If FastQ files are able to be submitted, submit and display basenames
if [[ ${#submitted[@]} -ge 1 ]]; then
  # Submit Nextflow pipeline to HPC
  qsub \
    -v SINGULARITY_CACHEDIR=${SINGULARITY_CACHEDIR} \
    -v SINGULARITY_TMPDIR=${SINGULARITY_TMPDIR} \
    -v OUT=${OUT} \
    -v IN=${IN} \
    -v LAB_HOME=${LAB_HOME} \
    -o ${OUT}/log/ \
    -e ${OUT}/log/ \
    -M ${USER}@cdc.gov \
    -m ba \
    -N ASM_${#submitted[@]} \
    -q all.q \
    ${LAB_HOME}/workflows/wf-paired-end-illumina-assembly/_run_assembly.uge-nextflow

  # Display basename of FastQ files submitted
  echo -e "\nInput directory: ${IN}"
  echo -e "Output directory: ${OUT}"
  echo -e "\n${GREEN}Generating annotated assemblies for:"
  for elem in "${submitted[@]}"; do
    echo "${elem}"
  done
  echo -e "${RESET}"
fi

# Set up log directory in OUT directory
mkdir -p ${OUT}/log
