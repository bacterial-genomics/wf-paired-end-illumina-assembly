#!/usr/bin/env bash
#$ -cwd

# This script is to run the wf-paired-end-illumina-assembly workflow on the UGE cluster

# Define script usage
usage() {
  echo "
Usage: ${0##*/} InputDirectory [OutputDirectory] [-h|--help]
  
Required:
  <InputDirectory>   Path containing PE Illumina 1.8+ files as *.fastq.gz
  
  Sample names are extracted from the first underscore of read files. Hyphens,
  periods, and commas are automatically discarded from the name to avoid errors.
  WARNING: If you have HiSeq data where samples are ran on more than one lane, 
  be sure to concatenate them.
  Sample pairing of sister reads is done by consecutively using filenames sorted
  with \`ls\`, which flexibly allows for naming other than traditional R1 and R2.
  Verify that files properly will pair by checking the output order of \`ls\`
  within the <InputDirectory>.
Optional:
  -h | --help        Show this help message and exit.
  <OutputDirectory>  Location for the output files, which
                     includes job logfiles. Output files
                     will be overwritten if already present.
                     Default: current working directory.     
  
  "
}

# Check if user has access to scratch area for Singularity files
check_if_user_has_access() {
  DESTINATION=${1} # full path to check
  VAR_NAME=${2} # variable name that is used (ex. SINGULARITY_BASE)
  EXPORT=false # if true, add export to variable
  if [ -r "${DESTINATION}" ]; then
    echo -e "Adding ${VAR_NAME} to user's bash configuration file..\n"
    if [ "${EXPORT}" = true ]; then
      echo -e "export ${VAR_NAME}=${DESTINATION}" >> ${HOME}/.bashrc
    else
      echo -e "${VAR_NAME}=${DESTINATION}" >> ${HOME}/.bashrc
    fi
  else
    echo -e "${RED}User does not have access to ${DESTINATION} for ${VAR_NAME}."
    echo -e "Workflow cannot continue. Exiting..${RESET}\n"
    exit 1
  fi
}

# Check if there is a possibility data will be overwritten in INPUT
check_if_previous_nextflow_run() {
  # Parameters:
  # $1 = file path
  # $2 = file to search for

  if [ -f $(find ${1} -name ${2} | grep -q '.') ]; then
    echo -e "\n${YELLOW}Previous Nextflow run found.${RESET}"
    read -p "It is possible that data will be overwritten. Do you want to continue? (enter YES or NO): " ANSWER

    # Continue submission if user wants to possibly overwrite data
    if [[ "${ANSWER}" = "Y" || "${ANSWER}" = "YES" || "${ANSWER}" = "y" || "${ANSWER}" = "yes" ]]; then
      echo -e "${GREEN}Data in ${1} will be overwritten. Continuing to submit samples..\n${RESET}"

    # If user doesn't want to continue, see if they want to provide a different output path
    elif [[ "${ANSWER}" = "N" || "${ANSWER}" = "NO" || "${ANSWER}" = "n" || "${ANSWER}" = "no" ]]; then
      read -p "Would you like to use a DIFFERENT OUTPUT path? (enter YES or NO): " PROCEED
      if [[ "${PROCEED}" = "Y" || "${PROCEED}" = "YES" || "${PROCEED}" = "y" || "${PROCEED}" = "yes" ]]; then
        read -p "Enter NEW OUTPUT path: " NEW_OUTPUT
        OUT=${NEW_OUTPUT}

        # Check new output. If trace*.txt is found, exit and ask for resubmission
        if [ -d "${OUT}/log" ] && [ -f $(find ${OUT}/log -name ${2} | grep -q '.') ]; then
          echo -e "${RED}Previous Nextflow run found."
          echo -e "Multiple attempts have been made for an empty output directory. Please locate and use an empty directory."
          echo -e "Submission is being cancelled..${RESET}"
          exit 1
        fi
        
      # If user doesn't want to provide a new path, exit
      elif [[ "${ANSWER}" = "N" || "${ANSWER}" = "NO" || "${ANSWER}" = "n" || "${ANSWER}" = "no" ]]; then
        echo -e "${RED}Submission is being cancelled..${RESET}"
        exit 1
      
      # Exit in case user inputs anything besides Yes, yes, Y, y, NO, no, N, n
      else
        echo -e "${RED}Invalid input. Valid inputs are: 'YES, yes, Y, y, NO, no, N, n.'."
        echo -e "Submission is being cancelled..${RESET}"
        exit 1
      fi

    # Exit in case user inputs anything besides Yes, yes, Y, y, NO, no, N, n
    else
      echo -e "${RED}Invalid input. Valid inputs are: YES, yes, Y, y, NO, no, N, n'."
      echo -e "Submission is being cancelled..${RESET}"
      exit 1
    fi
  fi
}

# Check requirements
[[ $1 == "--help" || $1 == "-h" ]] && { usage; exit 0; }
if [[ $# -lt 1  || $# -gt 2 ]]; then
  echo "ERROR: improper number ("$#") of arguments provided" >&2
  usage
  exit 1
fi

# Confirm we are on a host that can submit jobs
if [ ${HOSTNAME%%.*} == 'biolinux' ] || \
 [ ${HOSTNAME%%.*} == 'login02' ]; then
  :
else
  echo 'ERROR: must be on aspen or biolinux' >&2
  exit 1
fi

# I/O handling
if [[ $1 =~ .+[[:space:]].+ ]]; then
  echo "ERROR: whitespace in $1 path unsupported" >&2
  exit 1
fi
if [[ $2 =~ .+[[:space:]].+ ]]; then
  echo "ERROR: whitespace in $2 path unsupported" >&2
  exit 1
fi
IN=$(readlink -f "$1")
if [[ -z "$2" ]]; then
  OUT="${PWD}"
else
  OUT=$(readlink -f "$2")
fi

# Color output for success, warnings, and errors to catch user's attention
GREEN='\033[0;32m'
RED='\033[0;31m'
RESET='\033[0m'

# Get LAB_HOME or custom tmp/cache variables from .bashrc
source ${HOME}/.bashrc
if [[ -z "$LAB_HOME" ]]; then
  echo 'ERROR: $LAB_HOME not set' >&2
  exit 1
fi

# Check if needed Singularity variables are set. If not, try to add them
if [ -z "${SINGULARITY_BASE}" ]; then
  echo -e "SINGULARITY_BASE missing from bash shell configuration."
  check_if_user_has_access "/scicomp/scratch/$USER" "SINGULARITY_BASE" false
elif [ -z "${SINGULARITY_TMPDIR}" ]; then
  echo -e "SINGULARITY_TMPDIR missing from bash shell configuration."
  check_if_user_has_access "$SINGULARITY_BASE/singularity.tmp" "SINGULARITY_TMPDIR" true
elif [ -z "${SINGULARITY_CACHEDIR}" ]; then
  echo -e "SINGULARITY_CACHEDIR missing from bash shell configuration."
  check_if_user_has_access "$SINGULARITY_BASE/singularity.cache" "SINGULARITY_CACHEDIR" true
fi

# Set up tmp and cache directories for Singularity
mkdir -p ${HOME}/tmp && export TMPDIR=${HOME}/tmp
mkdir -pv $SINGULARITY_TMPDIR $SINGULARITY_CACHEDIR || true

# If Windows-style mount point (e.g., "Z:\Streptobacillus\Raw_FQs") given as a
#  path, check both user's home, lab home, and group as possible mount areas
#  to determine if files exist in 1 but not the others.
if [[ ${IN} =~ ^[A-Z]\:\\.+ ]]; then
  path_slashes_replaced="$(echo "${IN:3}" | sed 's/\\/\//g')"
  user_home="${HOME}"/"${path_slashes_replaced}"
  user_group_main="/scicomp/${path_slashes_replaced}"
  user_group_branch="/scicomp/groups/OID/NCEZID/DHCPP/BSPB/${path_slashes_replaced}"
  lab_home="${LAB_HOME}"/"${path_slashes_replaced}"
  paths=(
    "${user_home}"
    "${user_group_main}"
    "${user_group_branch}"
    "${lab_home}"
    )
  for path in "${paths[@]}"; do
    cnt_read_files=$(find "${path}" \
     -maxdepth 2 \
     -type f \
     -readable \
     -regextype posix-extended \
     -regex ".+\.(fq|fastq)($|\.gz$)" \
     2> /dev/null \
     | wc -l)
    if [[ ${cnt_read_files} -ge 1 ]]; then
        echo "${cnt_read_files} FastQ files found in: ${path}"
        read -p "Use ${path} as Input Directory? (yes|no)" -n 1 -r
        if [[ $REPLY =~ ^[yY] ]]; then
          IN="${path}"
        else
          exit 0
        fi
        break
    fi
  done
fi

# For now, just output into shared LAB_HOME area
if [[ ${OUT} =~ ^[A-Z]\:\\.+ ]]; then
  echo "Windows hard mount path detected as Output Directory"
  proposed_outpath="${LAB_HOME}"/"$(date '+%Y-%b-%d_%a_%H:%M:%S')"
  read -p "Use ${path} as Input Directory? (yes|no)" -n 1 -r
  if [[ $REPLY =~ ^[yY] ]]; then
    OUT="${path}"
  else
    echo "Okay, bad autoselection? Re-run with a different specified path"
    exit 0
  fi
fi

# If Windows-style path from Core Facility given via email
#  (e.g., "\\...cdc.gov\groups\OID\...BCFB\by-instrument\NovaSeq\")
#  is given as path, form the Linux path
if [[ ${IN} =~ ^\\\\.+\.cdc\.gov\\.+\\.+ ]]; then
  inpath_stripped_hostname="${IN/*.cdc\.gov/\/scicomp}"
  inpath_dewindowsed="$(echo "${inpath_stripped_hostname}" | sed 's/\\/\//g')"
  IN="${inpath_dewindowsed}"
fi

# Check nextflow log dir for trace*.txt file --> means nextflow has been ran before
if [ -d "${OUT}/log" ]; then
  check_if_previous_nextflow_run "${OUT}/log" "trace*.txt"
# Also check for unsupported behavior combining legacy bash and newer nextflow
elif [ -d "${OUT}/.log" ] && \
  [ -f "${OUT}/trim.asm.annot.job_ids.txt" ] && \
  [ -f "${OUT}/trim.asm.annot.log.txt" ]; then
  echo "Legacy bash workflow detected in ${OUT}"
  echo "Combining data from that and this nextflow pipeline is unsupported."
  echo "Use a different output path."
  exit 1
fi

# Add found files to an array
found_files=( $(find ${IN} -name "*fastq.gz" -o -name "*fq.gz") )

# Check to see if FastQ files are present in IN
if [[ ${#found_files[@]} -ge 2 ]]; then
  # Arrays for submissions
  submitted=()
  not_submitted=()

  # Counter to count basename - if >=1, skips following lines
  unset counter
  declare -A counter

  # Loop over find command for fastq.gz files
  for line in "${found_files[@]}"; do
    base=$(basename ${line} | sed -r 's/(_R).*$//') # Cut filename at 'R' or else x_ and x1_ will show submitted
    clean_base=$(echo $base | sed 's/[-._]*$//') # Remove trailing separators to display later
    count=$(find ${IN} -name "${base}*" | wc -l)
    (( counter[${base}]++ )) || \
    if [[ $(( ${count}/2 )) -ge 1 ]]; then
      submitted+=(${clean_base})
    else
      not_submitted+=(${clean_base})
    fi
  done

# Give error message if FastQ files are not found
else
  echo -e "FastQ files are not found in ${IN}"
  exit 1
fi

# Prompt user if >10 samples to prevent accidentally assembling too many
if [[ ${#submitted[@]} -ge 10 ]]; then
  echo -e "${RED}WARNING:${RESET} ${#submitted[@]} samples have been identified. Identified samples:\n${RESET}"
  echo -e "${submitted[@]}\n"
  
  # Ask if user wants to submit all the samples
  read -p "Do you want to continue submitting ${#submitted[@]} samples? (enter YES or NO): " ANSWER
  if [[ "${ANSWER}" = "Y" || "${ANSWER}" = "YES" || "${ANWER}" = "y" || "${ANSWER}" = "yes" ]]; then
    echo -e "Continuing to submit ${#submitted[@]} samples..\n"
  elif [[ "${ANSWER}" = "N" || "${ANSWER}" = "NO" || "${ANWER}" = "n" || "${ANSWER}" = "no" ]]; then
    echo -e "Submission cancelled"
    exit 1
  else
    # Error catching
    echo -e "Invalid input. Valid inputs are: YES, yes, Y, y, NO, no, N, n."
    echo -e "Submission is being cancelled.."
    exit 1
  fi
fi

# If FastQ files are able to be submitted, submit and display basenames
if [[ ${#submitted[@]} -ge 1 ]]; then
  # Submit Nextflow pipeline to HPC
  qsub \
    -v SINGULARITY_CACHEDIR=${SINGULARITY_CACHEDIR} \
    -v TMPDIR=${TMPDIR} \
    -v OUT=${OUT} \
    -v IN=${IN} \
    -v LAB_HOME=${LAB_HOME} \
    -o ${OUT}/log/ \
    -e ${OUT}/log/ \
    -M ${USER}@cdc.gov \
    -m ba \
    -N ASM_${#submitted[@]} \
    -q all.q \
    ${LAB_HOME}/workflows/wf-paired-end-illumina-assembly/_run_assembly.uge-nextflow

  # Display basename of FastQ files submitted
  echo -e "\nInput directory: ${IN}"
  echo -e "Output directory: ${OUT}"
  echo -e "\n${GREEN}Generating annotated assemblies for:"

  for elem in "${submitted[@]}"; do
    echo "${elem}"
  done
  echo -e "${RESET}"
fi

# Display basename of FastQ files that weren't submitted
if [[ ${#not_submitted[@]} -ge 1 ]]; then
  echo -e "${RED}Cannot generate assemblies for:"
  for elem in "${not_submitted[@]}"; do
    echo "${elem}"
  done
  echo -e "${RESET}"
fi

# Set up log directory in OUT directory
mkdir -p ${OUT}/log
